
/**
  \mainpage

	\tableofcontents

  \section intro Introduction

  The main purpose of this documentation is to describe the ReDex code.
  Unfortunately, the code base of redex is not documented in any
  consistent way, although several pieces of code have documenting
  comments in them.

  Still, the description below as well as the class summaries generated by
  doxygen provide useful information to anyone wishing to read/write code
  in ReDex.

  The secondary purpose of the documentation is to document the Clue-ReDex
  extentions.

  \subsection intro_exec_redex Executing redex

  The \b redex command is actually a self-extracting file, which extracts into a python wrapper and the
  \b redex-all binary. The python wrapper is responsible for unpacking an .apk file, exposing the .dex file(s) in it.
  Then, \b redex-all analyses and rewrites the .dex files, and finally the python wrapper reassemples the
  .apk file. The complete logic of the python wrapper is contained in file redex.py and in the pyredex package.

  \subsection intro_redex_all The execution of redex-all

  The file containing the \c main() function is  tools/redex-all/main.cpp. At a high level, the tasks performed
  in the main function are the following

    1. Arguments are parsed.
    2. The RedexContext global object, `g_redex`, is created
    3. The %ProGuard configuration is read
    4. The root DexStore object is created. It corresponds to the .dex files on the command line.
        When an .apk contains other Application Modules inside it, each application module is stored
        in its own DexStore object.
		  Note that the file on the command line must end in '.dex', or else it must be a so-called "metadata"
		  file (see DexMetadata for more).
	5. A list of external .jar files ("library jars") is also read into a Scope obect
	6. Names are de-obfuscated by using ProGuard map files.
	7. A PassManager is created and passes are executed according to configuration
	8. Optimized .dex files are written to disk.

\section passes Passes

A pass is defined as a subclass of abstract class Pass. The execution of passes happens in two steps.
In the first step, method Pass::eval_pass() is executed for each pass. In the second step, method Pass::run_pass()
is executed. The idea is that during the first step, each pass can see the original input in the dex stores
whereas in the second pass the order of passes affects what each pass encounters.

Each Pass subclass is a singleton class and it is instantiated as a static. A PassRegistry singleton object
obtained via PassRegistry::get() is used to hold pointers to all instantiated Pass objects. This happens
automatically, in the constructor of the Pass class. Unfortunately, the destructor does not remove an object
from the registry [NOTE: maybe fix this?], therefore Pass objects \em should be made static to avoid strange
errors.

Note: care must be taken when linking with these static objects,
the current build machinery has this nailed down.

\subsection passes_execution Execution of passes

The execution of passes is controlled by a PassManager object. When a PassManager instance is created, it
is given a vector of pointers to Pass objects (by default in redex, this is gone by calling
PassRegistry::get().get_passes() but another vector can be provided, e.g., in tests).

Then the PassManager instance looks at the configuration file, a Json::Value instance which contains a
list of passes to be activated and optionally configuration for each pass. For example, the following
snippet
\verbatim
{
  "redex" : {
    "passes": ["MyPass", ...]
  },
  "MyPass":  <config options>
}
\endverbatim
declares that a pass named "MyPass" should be executed first. When the PassManager reads in the list
of passes, for each pass it calls method Pass::configure_pass() providing the '<config options>' for this
pass.

If some pass should be executed multiple times, it can be denoted as follows
\verbatim
{
  "redex" : {
    "passes": ["MyPass#1", ..., "MyPass#2", ...]
  },
  "MyPass#1":  <config options>
  "MyPass#2":  <config options>
}
\endverbatim
This will activate the 'MyPass' object twice (in the given order). It will also call
Pass::configure_pass() twice on that object.

Once all passes of a run are activated, the PassManager::run_passes() method can be called to
execute all passes, first calling all Pass::eval_pass() methods and then calling all Pass::run_pass() methods.
The PassManager instance is given as an argument to these calls, and each call may get information on
the current call by calling PassManager::get_current_pass_info().


\section dex_file_model The DEX model

A relatively detailed description of Dalvik, ART, the DEX bytecode and file format etc
can be found in https://source.android.com/devices/tech/.

At a high level, the contents of an .apk file are organized into a vector of DexStore
objects. Each DexStore object contains a sequence of "dexes" DexStore::get_dexen()
where a "dex" is an instance of type DexClasses. Type DexClasses is defined as an std::vector
of DexClass pointers. DexClass is the root object from which all class members can be found.

\subsection dex_fm_creation Creation of new entities

The libredex code enforces uniqueness for every object in the DEX model. This is enforced by
the "private constructor" pattern; therefore, to construct a new object, one must use some static
method in the API. The DexLoader class contains code for creating objects from a .dex file on disk.

The Creators.h file contains some code for creating new entities, in particular classes and methods.

\subsection dex_fm_iteration Iteration over sets of entities

There are several ways to iterate over collections. For example, the code in Walkers.h
contains a number of static member functions of class @ref walk implement the visitor design pattern
using range-based for loops. For example, the following code will call function foo over a set of classes
\code
void foo(DexClass* cls) { ... }
Scope some_classes;  // this is just a type alias for std::vector<DexClass*>
// .. add classes to scope
walk::classes(some_classes, foo);
\endcode
When parallel execution is allowed, one can use
\code
walk::parallel::classes(some_classes, foo);
\endcode

\subsection dex_fm_code Working with code

Dalvik code is represented by several encodings:

- DexCode represents the lowest-level encoding, close to the serialization format of .dex files.
- Classes whose name begins with 'IR', and in particular IRCode, IRList and IRInstruction hold binary code.
IRList is just a list of MethodItemEntry objects. Each MethodItemEntry object is essentially a union that
can hold TryEntry, CatchEntry, IRInstruction or BranchTarget items.
- A newer API for code is in namespace cfg (stands for control flow graph), namely classes cfg::ControlFlowGraph
and cfg::Block.
q
Currently, facebook-redex is transiting code manipulation from the IRCode API to the new cfg API.

Normally, one need not work with DexCode objects; the library creates IRCode objects for all methods at load
time. Given an IRCode object, one can call methods IRCode::build_cfg() and IRCode::clear_cfg() to create
the CFG for a given method code. When IRCode::build_cfg() is called with an argument of `true`, the CFG is
editable, i.e., all changes made to it are passed back to the owning IRCode object when IRCode::clear_cfg() is
called.

DexUtil.h contains useful functions for working with code

\section testing_the_code Testing the code

In order to write unit tests for new code, there is a number of facilities.
Since we are using GNU autotools,
the test execution happens by
> make check
to run all tests, and
> make recheck
to run only tests that failed previously.

N.B. At this time [Aug/18] the facebook-redex test code is not maintained well,
therefore only a subset of
the tests compile and run.

 \subsection testing_tracing Tracing execution

   Inside the code, one can use the @ref TRACE macro to generate messages as the code executes.
   >  TRACE(MODULE, trace_level, fmt, ...)
   The above printf-ish call designates a module and a level. Modules are listed in libredex/Trace.h
   and you can add your own modules there. The level is a positive integer (higher means more detail).
   Typical values are 1 and 2. The `fmt` and the following args are passed to a printf formatter.

   Tracing is enabled by environment variables:
   > TRACE= level
   The above must be defined for any tracing to happen.
   Finer configuration of tracing can be done with
   - TRACEFILE: filename to send trace output to
   - SHOW_TIMESTAMPS: if defined, show timestamps
   - SHOW_TRACEMODULE: if defined, show module name
   - TRACE_METHOD_FILTER: if defined, list of module names to trace

 \subsection testing_assertions Adding assertions

   There are several useful assertion macros in libredex/Debug.h. Follow the
   link to read them.

   N.B. There is also the @ref CHECK macro in shared/Util.h. This macro is not
   currently used in the code,
   so don't use it (it may be removed from facebook-redex later)!

 \subsection testing_writing Writing tests for clue-redex

 Tests can be written using the Google Test library. See
 https://github.com/google/googletest for the documentation.
 The facebook-redex code uses this library as well.

 Tests can be added to directory test/clue. In order to write a test suite you
 can start by copying file test/clue/SampleTest.cpp to a new filename. Also, add
 your new test file to test/clue/Makefile.am, following
 the pattern for sample_test in that file (note: Makefile.am is a template
 for generating a Makefile using GNU automake. For more features of GNU automake,
 see the
 [automake documentation](https://www.gnu.org/software/automake/manual/automake.html) )

 When writing tests that require redex to load some code, the ClueTest fixture
 class becomes handy. To use it in a
 test, write the test function as
 \code
 TEST_F(ClueTest, mytestfun) {
	...
 }
 \endcode
 Inside the body of this function, one can load .dex files, run passes etc. in
 a straightforward way. Refer to the
 SampleTest.cpp file and the tests therein.


*/
